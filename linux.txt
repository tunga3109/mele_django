cd - вход в директорию
ls - содержимое директории
pwd - посмотреть текущую директорию
man <fuction> - документация каждого утилита (флаги)
cat <file> - просмотр файла
stat <func> or <file> - посмотреть инфу по файлу или папке
ls -a <dir> - посмотреть скрытые файлы
head -n 2 .bashrc - посмотреть первые 2 строки файла баш
tail -n 2 .bashrc - посмотреть последние 2 строки
grep <word> <file or dir> - поиск слова по файлам и дирам
nano .bashrc - редактор файлов
vim .bashrc - редактор файлов 2

Говорят, что самое сложное в виме — это выйти, поэтому подготовимся заранее. Убедитесь, что вы находитесь в командном режиме, на всякий случай нажмите Esc (или комбинацию Ctrl + [). Затем наберите :, эта команда переведёт вас в режим командной строки (ещё один режим), затем введите q! и нажмите Enter. Так вы выйдете из вима без сохранения изменений. Если набрать :wq, то перед выходом сохранятся все изменения. Если вы хотите просто сохраниться без выхода, то наберите :w.

echo <word> -  записать слово


cat source | grep Dog | uniq | sort
Читается файл source
Входные данные грепаются по подстроке "Dog"
Убираются дубли (в исходном файле две одинаковых строки "Dog")
Входные данные сортируются и выводятся на экран

| — этот символ называется пайп, он указывает шеллу взять STDOUT одного процесса, и соединить его с STDIN другого процесса.

# В текущей директории создаётся пустой файл
touch empty-file

#Удаляется файл командой rm (remove files):
rm empty-file

#Переименование файла
touch file
mv file <files new>


# Для копирования файлов и директорий используется утилита cp (copy). Её первый аргумент — имя источника (откуда), второй — имя приёмника (куда).
cp renamed-file renamed-file-copy

# Создание директории выполняется командой mkdir (make directory).
mkdir <dir>

# В такой ситуации придётся либо создавать каждую директорию отдельно, либо воспользоваться флагом -p, который создаёт директории рекурсивно.
mkdir -p <dir1>/<dir_2>/<dir3>

# Удаление директории
rm -r <dir>

#удаляет всю директорию 
rm -rf <dir>

# Для вывода переменной используется echo,
# а перед самой переменной ставится знак $.
echo $HOME

# Вокруг знака равно не должно быть пробелов
HOME=/tmp
echo $HOME

/tmp

# Возвращаем обратно
HOME=/home/kirill.m
echo $HOME

/home/kirill.m
____________________

Иногда бывает нужно выполнить команду из-под пользователя, отличного от root. Тогда придётся добавить флаг -u:

sudo -u nobody mkdir /tmp/test
# Файл создан от nobody
stat /tmp/test

  File: '/tmp/test'
  Size: 4096        Blocks: 8          IO Block: 4096   directory
Device: ca01h/51713d    Inode: 4577        Links: 2
Access: (0755/drwxr-xr-x)  Uid: (65534/  nobody)   Gid: (65534/ nogroup)

Если стоит задача произвести сразу пачку действий от имени другого пользователя, то для этого можно запустить новую оболочку внутри текущей (говорят что мы стартуем новую сессию):

sudo -i
id

uid=0(root) gid=0(root) groups=0(root)
Главное — не забыть переключиться обратно после завершения необходимых манипуляций. Для этого наберите exit.

_____________________


# Нет прав на выполнение
touch /etc/myfile

touch: cannot touch '/etc/myfile': Permission denied

# С sudo все работает
sudo touch /etc/myfile

# Видно что владелец файла root
stat /etc/myfile

  File: '/etc/myfile'
  Size: 0           Blocks: 0          IO Block: 4096   regular empty file
Device: ca01h/51713d    Inode: 2761        Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)

# Нет прав на удаление
rm /etc/myfile

rm: remove write-protected regular empty file '/etc/myfile'? y
rm: cannot remove '/etc/myfile': Permission denied

# Опять помогло sudo
sudo rm /etc/myfile
______________________

# Требует sudo, потому что установка идет в системные директории
sudo apt install <program>
# Здесь будет много текста и вопрос, устанавливать ли? Если да, то установится PHP

apt remove <program>
# Тут тоже много вывода и вопрос, удалять ли?
